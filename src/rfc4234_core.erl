%%% Do not modify this file, it is automatically generated by abnfc.
%%% All changes will be lost when it is regenerated.
%%% Generated by abnfc_gen on 2012-12-28 11:02:51

-module(rfc4234_core).

-ifdef('QC').

-include_lib("qc/include/qc.hrl").

-endif.

-export([names/0]).

-export(['ALPHA'/0, 'BIT'/0, 'CHAR'/0, 'CR'/0, 'CRLF'/0,
	 'CTL'/0, 'DIGIT'/0, 'DQUOTE'/0, 'HEXDIG'/0, 'HTAB'/0,
	 'LF'/0, 'LWSP'/0, 'OCTET'/0, 'SP'/0, 'VCHAR'/0, 'WSP'/0,
	 decode/2]).

-ifdef('QC').

-export(['ALPHA_generator'/0, 'BIT_generator'/0,
	 'CHAR_generator'/0, 'CRLF_generator'/0,
	 'CR_generator'/0, 'CTL_generator'/0,
	 'DIGIT_generator'/0, 'DQUOTE_generator'/0,
	 'HEXDIG_generator'/0, 'HTAB_generator'/0,
	 'LF_generator'/0, 'LWSP_generator'/0,
	 'OCTET_generator'/0, 'SP_generator'/0,
	 'VCHAR_generator'/0, 'WSP_generator'/0, generator/1]).

-endif.

-include("rfc4234_core.hrl").

names() ->
    ['ALPHA', 'BIT', 'CHAR', 'CR', 'CRLF', 'CTL', 'DIGIT',
     'DQUOTE', 'HEXDIG', 'HTAB', 'LF', 'LWSP', 'OCTET', 'SP',
     'VCHAR', 'WSP'].

decode('ALPHA', Str) -> ('ALPHA'())(Str);
decode('BIT', Str) -> ('BIT'())(Str);
decode('CHAR', Str) -> ('CHAR'())(Str);
decode('CR', Str) -> ('CR'())(Str);
decode('CRLF', Str) -> ('CRLF'())(Str);
decode('CTL', Str) -> ('CTL'())(Str);
decode('DIGIT', Str) -> ('DIGIT'())(Str);
decode('DQUOTE', Str) -> ('DQUOTE'())(Str);
decode('HEXDIG', Str) -> ('HEXDIG'())(Str);
decode('HTAB', Str) -> ('HTAB'())(Str);
decode('LF', Str) -> ('LF'())(Str);
decode('LWSP', Str) -> ('LWSP'())(Str);
decode('OCTET', Str) -> ('OCTET'())(Str);
decode('SP', Str) -> ('SP'())(Str);
decode('VCHAR', Str) -> ('VCHAR'())(Str);
decode('WSP', Str) -> ('WSP'())(Str).

-ifdef('QC').

generator('ALPHA') -> 'ALPHA_generator'();
generator('BIT') -> 'BIT_generator'();
generator('CHAR') -> 'CHAR_generator'();
generator('CR') -> 'CR_generator'();
generator('CRLF') -> 'CRLF_generator'();
generator('CTL') -> 'CTL_generator'();
generator('DIGIT') -> 'DIGIT_generator'();
generator('DQUOTE') -> 'DQUOTE_generator'();
generator('HEXDIG') -> 'HEXDIG_generator'();
generator('HTAB') -> 'HTAB_generator'();
generator('LF') -> 'LF_generator'();
generator('LWSP') -> 'LWSP_generator'();
generator('OCTET') -> 'OCTET_generator'();
generator('SP') -> 'SP_generator'();
generator('VCHAR') -> 'VCHAR_generator'();
generator('WSP') -> 'WSP_generator'().

-endif.

'ALPHA'() ->
    fun ([C | Tl]) when (C >= 65) and (C =< 90) ->
	    {ok, C, Tl};
	([C | Tl]) when (C >= 97) and (C =< 122) -> {ok, C, Tl};
	(_) -> fail
    end.

'BIT'() ->
    fun ([C | Tl]) when (C >= 48) and (C =< 49) ->
	    {ok, C, Tl};
	(_) -> fail
    end.

'CHAR'() ->
    fun ([C | Tl]) when (C >= 1) and (C =< 127) ->
	    {ok, C, Tl};
	(_) -> fail
    end.

'CR'() ->
    fun ([13 | Tl]) -> {ok, 13, Tl};
	(_) -> fail
    end.

'CRLF'() ->
    '__alt'(['LF'(), '__seq'(['CR'(), 'LF'()])]).

'CTL'() ->
    fun ([C | Tl]) when (C >= 0) and (C =< 31) ->
	    {ok, C, Tl};
	([C | Tl]) when C == 127 -> {ok, C, Tl};
	(_) -> fail
    end.

'DIGIT'() ->
    fun ([C | Tl]) when (C >= 48) and (C =< 57) ->
	    {ok, C, Tl};
	(_) -> fail
    end.

'DQUOTE'() ->
    fun ([34 | Tl]) -> {ok, 34, Tl};
	(_) -> fail
    end.

'HEXDIG'() ->
    '__alt'(['DIGIT'(),
	     fun ([C | Tl]) when C == 97 -> {ok, C, Tl};
		 ([C | Tl]) when C == 65 -> {ok, C, Tl};
		 (_) -> fail
	     end,
	     fun ([C | Tl]) when C == 98 -> {ok, C, Tl};
		 ([C | Tl]) when C == 66 -> {ok, C, Tl};
		 (_) -> fail
	     end,
	     fun ([C | Tl]) when C == 99 -> {ok, C, Tl};
		 ([C | Tl]) when C == 67 -> {ok, C, Tl};
		 (_) -> fail
	     end,
	     fun ([C | Tl]) when C == 100 -> {ok, C, Tl};
		 ([C | Tl]) when C == 68 -> {ok, C, Tl};
		 (_) -> fail
	     end,
	     fun ([C | Tl]) when C == 101 -> {ok, C, Tl};
		 ([C | Tl]) when C == 69 -> {ok, C, Tl};
		 (_) -> fail
	     end,
	     fun ([C | Tl]) when C == 102 -> {ok, C, Tl};
		 ([C | Tl]) when C == 70 -> {ok, C, Tl};
		 (_) -> fail
	     end]).

'HTAB'() ->
    fun ([9 | Tl]) -> {ok, 9, Tl};
	(_) -> fail
    end.

'LF'() ->
    fun ([10 | Tl]) -> {ok, 10, Tl};
	(_) -> fail
    end.

'LWSP'() ->
    '__repeat'(0, infinity,
	       '__alt'(['WSP'(), '__seq'(['CRLF'(), 'WSP'()])])).

'OCTET'() ->
    fun ([C | Tl]) when (C >= 0) and (C =< 255) ->
	    {ok, C, Tl};
	(_) -> fail
    end.

'SP'() ->
    fun ([32 | Tl]) -> {ok, 32, Tl};
	(_) -> fail
    end.

'VCHAR'() ->
    fun ([C | Tl]) when (C >= 33) and (C =< 126) ->
	    {ok, C, Tl};
	(_) -> fail
    end.

'WSP'() -> '__alt'(['SP'(), 'HTAB'()]).

-ifdef('QC').

'ALPHA_generator'() ->
    ?'LET'(V4,
	   (?'LET'(V3,
		   (oneof([?'LET'(V1, (choose(65, 90)), V1),
			   ?'LET'(V2, (choose(97, 122)), V2)])),
		   V3)),
	   V4).

'BIT_generator'() ->
    ?'LET'(V3,
	   (?'LET'(V2, (oneof([?'LET'(V1, (choose(48, 49)), V1)])),
		   V2)),
	   V3).

'CHAR_generator'() ->
    ?'LET'(V2, (?'LET'(V1, (choose(1, 127)), V1)), V2).

'CR_generator'() ->
    ?'LET'(V2, (?'LET'(V1, 13, V1)), V2).

'CRLF_generator'() ->
    ?'LET'(V6,
	   (?'LET'(V5,
		   (oneof([?'SIZED'(V1,
				    (resize(if V1 > 0 -> V1 - 1;
					       true -> 0
					    end,
					    'LF_generator'()))),
			   ?'LET'(V4,
				  ('__seq_generator'([?'SIZED'(V2,
							       (resize(if V2 > 0 -> V2 - 1;
									  true -> 0
								       end,
								       'CR_generator'()))),
						      ?'SIZED'(V3,
							       (resize(if V3 > 0 -> V3 - 1;
									  true -> 0
								       end,
								       'LF_generator'())))])),
				  V4)])),
		   V5)),
	   V6).

'CTL_generator'() ->
    ?'LET'(V4,
	   (?'LET'(V3,
		   (oneof([?'LET'(V1, (choose(0, 31)), V1),
			   ?'LET'(V2, 127, V2)])),
		   V3)),
	   V4).

'DIGIT_generator'() ->
    ?'LET'(V2, (?'LET'(V1, (choose(48, 57)), V1)), V2).

'DQUOTE_generator'() ->
    ?'LET'(V2, (?'LET'(V1, 34, V1)), V2).

'HEXDIG_generator'() ->
    ?'LET'(V21,
	   (?'LET'(V20,
		   (oneof([?'SIZED'(V1,
				    (resize(if V1 > 0 -> V1 - 1;
					       true -> 0
					    end,
					    'DIGIT_generator'()))),
			   ?'LET'(V4,
				  (oneof([?'LET'(V2, 97, V2), ?'LET'(V3, 65, V3)])), V4),
			   ?'LET'(V7,
				  (oneof([?'LET'(V5, 98, V5), ?'LET'(V6, 66, V6)])), V7),
			   ?'LET'(V10,
				  (oneof([?'LET'(V8, 99, V8), ?'LET'(V9, 67, V9)])), V10),
			   ?'LET'(V13,
				  (oneof([?'LET'(V11, 100, V11), ?'LET'(V12, 68, V12)])),
				  V13),
			   ?'LET'(V16,
				  (oneof([?'LET'(V14, 101, V14), ?'LET'(V15, 69, V15)])),
				  V16),
			   ?'LET'(V19,
				  (oneof([?'LET'(V17, 102, V17), ?'LET'(V18, 70, V18)])),
				  V19)])),
		   V20)),
	   V21).

'HTAB_generator'() ->
    ?'LET'(V2, (?'LET'(V1, 9, V1)), V2).

'LF_generator'() ->
    ?'LET'(V2, (?'LET'(V1, 10, V1)), V2).

'LWSP_generator'() ->
    ?'LET'(V7,
	   (?'LET'(V6,
		   ('__repeat_generator'(0, infinity,
					 ?'LET'(V5,
						(oneof([?'SIZED'(V1,
								 (resize(if V1 > 0 -> V1 - 1;
									    true -> 0
									 end,
									 'WSP_generator'()))),
							?'LET'(V4,
							       ('__seq_generator'([?'SIZED'(V2,
											    (resize(if
												      V2
													>
													0 ->
													  V2
													    -
													    1;
												      true ->
													  0
												    end,
												    'CRLF_generator'()))),
										   ?'SIZED'(V3,
											    (resize(if
												      V3
													>
													0 ->
													  V3
													    -
													    1;
												      true ->
													  0
												    end,
												    'WSP_generator'())))])),
							       V4)])),
						V5))),
		   V6)),
	   V7).

'OCTET_generator'() ->
    ?'LET'(V2, (?'LET'(V1, (choose(0, 255)), V1)), V2).

'SP_generator'() ->
    ?'LET'(V2, (?'LET'(V1, 32, V1)), V2).

'VCHAR_generator'() ->
    ?'LET'(V2, (?'LET'(V1, (choose(33, 126)), V1)), V2).

'WSP_generator'() ->
    ?'LET'(V4,
	   (?'LET'(V3,
		   (oneof([?'SIZED'(V1,
				    (resize(if V1 > 0 -> V1 - 1;
					       true -> 0
					    end,
					    'SP_generator'()))),
			   ?'SIZED'(V2,
				    (resize(if V2 > 0 -> V2 - 1;
					       true -> 0
					    end,
					    'HTAB_generator'())))])),
		   V3)),
	   V4).

-endif.

'__alt'(Ps) -> fun (T) -> '__do_alt'(Ps, T) end.

'__do_alt'([P | Ps], T) ->
    case P(T) of
      {ok, _R, _T1} = Res -> Res;
      fail -> '__do_alt'(Ps, T)
    end;
'__do_alt'([], _) -> fail.

'__repeat'(Min, Max, P) -> '__repeat'(Min, Max, P, 0).

'__repeat'(Min, Max, P, Found) ->
    fun (T) -> '__do_repeat'(Min, Max, P, Found, T) end.

'__do_repeat'(Min, Max, P, Found, T) ->
    case P(T) of
      {ok, R1, T1} when Max == Found + 1 -> {ok, [R1], T1};
      {ok, R1, T1} ->
	  case '__do_repeat'(Min, Max, P, Found + 1, T1) of
	    {ok, R2, T2} -> {ok, [R1 | R2], T2};
	    fail when Found >= Min -> {ok, [R1], T1};
	    fail -> fail
	  end;
      fail when Found >= Min -> {ok, [], T};
      fail -> fail
    end.

'__seq'(Ps) -> fun (T) -> '__do_seq'(Ps, T) end.

'__do_seq'([P | Ps], T) ->
    case P(T) of
      {ok, R1, T1} ->
	  case '__do_seq'(Ps, T1) of
	    {ok, R2, T2} -> {ok, [R1 | R2], T2};
	    fail -> fail
	  end;
      fail -> fail
    end;
'__do_seq'([], T) -> {ok, [], T}.

-ifdef('QC').

'__repeat_generator'(Min, Max, G) ->
    ?'SIZED'(Size,
	     begin
	       MAX = if Max /= infinity -> Max;
			true -> Size
		     end,
	       ?'LET'(K,
		      if Min >= MAX -> Min;
			 true -> choose(Min, MAX)
		      end,
		      (vector(K, G)))
	     end).

-endif.

-ifdef('QC').

'__seq_generator'(Gs) -> '__do_seq_generator'(Gs, []).

-endif.

-ifdef('QC').

'__do_seq_generator'([], Acc) -> lists:reverse(Acc);
'__do_seq_generator'([H | T], Acc) ->
    ?'LET'(K, H, ('__do_seq_generator'(T, [K | Acc]))).

-endif.
