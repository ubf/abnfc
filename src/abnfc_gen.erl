%%%-------------------------------------------------------------------
%%% @copyright 2009 Anders Nygren
%%% @author Anders Nygren <anders.nygren@gmail.com>
%%% @doc Code generation.
%%% @end
%%%-------------------------------------------------------------------
-module(abnfc_gen).

%% API
-export([generate/2]).

-compile(export_all).

-import(erl_syntax, [application/2,application/3,
                     arity_qualifier/2,
                     atom/1,
                     attribute/1,attribute/2,
                     binary/1,
                     binary_field/1,binary_field/2,
                     block_expr/1,
                     case_expr/2,
                     class_qualifier/2,
                     clause/3,
                     comment/1,
                     conjunction/1,
                     cons/2,
                     eof_marker/0,
                     form_list/1,
                     fun_expr/1,
                     function/2,
                     if_expr/1,
                     infix_expr/3,
                     integer/1,
                     list/1,list/2,
                     macro/2,
                     match_expr/2,
                     nil/0,
                     operator/1,
                     string/1,
                     try_expr/3,
                     tuple/1,
                     variable/1
                    ]).

-include("abnfc_ast.hrl").

%%====================================================================
%% API
%%====================================================================
%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
generate(AST, Opts) ->
    Verbose = proplists:get_bool(verbose,Opts),
    maybe_write("Opts ~p~n",[Opts],Verbose),
    Module = proplists:get_value(mod,Opts),
    Prefix = proplists:get_value(prefix,Opts),
    Type = case proplists:get_bool(binary, Opts) of
               true -> binary;
               false -> list
           end,
    Names = [R#rule.name||R<-AST],
    Res=form_list([header_comments(),
                   attribute(atom(module), [atom(Module)]),
                   gen_ifdef(include_gen(Module)),
                   exports_names(),
                   exports(Prefix, Names),
                   gen_ifdef(exports_gen(Prefix, Names)),
                   include(Module),
                   gen_names(Names),
                   gen_dec(Prefix, Names),
                   gen_ifdef(gen_gen(Prefix, Names)),
                   form_list([form_list([gen_rule(R, Type, Prefix, Verbose)]) || R <- AST]),
                   gen_ifdef(form_list([form_list([gen_generator(R, Type, Prefix, Verbose)]) || R <- AST])),
                   mk__alt(),
                   mk__do_alt(),
                   mk__repeat(),
                   mk__seq(),
                   mk__do_seq(),
                   gen_ifdef(mk__repeat_generator()),
                   gen_ifdef(mk__seq_generator()),
                   gen_ifdef(mk__do_seq_generator()),
                   eof_marker()]),
    {ok, erl_prettypr:format(Res)}.

%%====================================================================
%% Internal functions - common
%%====================================================================

header_comments() ->
    {{Year,Month,Day},{Hour,Min,Sec}} = erlang:localtime(),
    DT = lists:flatten(
           io_lib:format("~w-~2.2.0w-~2.2.0w ~2.2.0w:~2.2.0w:~2.2.0w",
                         [Year,Month,Day,Hour,Min,Sec])),
    comment(["%% Do not modify this file, it is automatically generated by abnfc.",
             "%% All changes will be lost when it is regenerated.",
             "%% Generated by abnfc_gen on "++DT]).

exports_names() ->
    attribute(atom(export),
              [list([arity_qualifier(atom(names),integer(0))])]).

gen_names(Names) ->
    function(atom(names),
             [clause([],[],
                     [list([atom(Name)||Name<-Names])])]).

maybe_write(Fmt,Args,true) ->
    io:format(Fmt,Args);
maybe_write(_Fmt,_Args,false) ->
    ok.

%%====================================================================
%% Internal functions - decode
%%====================================================================

dec_atom(Prefix, A) ->
    atom(list_to_atom(atom_to_list(Prefix)++atom_to_list(A))).

exports(Prefix, Funs) ->
    attribute(atom(export),
              [list([arity_qualifier(atom(decode),integer(2))]++
                        [arity_qualifier(dec_atom(Prefix, F),integer(0))||F<-Funs])]).

include(Module) ->
    attribute(atom(include),[string(lists:concat([Module,".hrl"]))]).

gen_dec(Prefix, Names) ->
    function(atom(decode),
             [clause([atom(Name),variable('Str')],[],
                     [application(application(dec_atom(Prefix, Name),[]),[variable('Str')])])||Name<-Names]).

gen_rule(#rule{name=Name, body=Element, code=nocode}, Type, Prefix, Verbose) ->
    maybe_write("abnfc_gen: generating rule ~p~p~n",[Prefix,Name],Verbose),
    Body = gen_elem(Element, Type, Prefix),
    mk_rule_fun(Prefix, Name, Body);

gen_rule(#rule{name=Name, body=Element, code=Code}, Type, Prefix, Verbose) ->
    maybe_write("abnfc_gen: generating rule ~p~p~n",[Prefix,Name],Verbose),
    Vars = gen_vars(Element),
    Body = gen_elem(Element, Type, Prefix),
    mk_rule_fun(Prefix, Name, Body, Vars, Code).

mk_rule_fun(Prefix, Name, {tree, fun_expr, _, _}=Body) ->
    function(
      dec_atom(Prefix, Name),
      [clause([],[],
              [Body])]);

mk_rule_fun(Prefix, Name, Body) ->
    function(
      dec_atom(Prefix, Name),
      [clause([],[],
              [Body])]).

mk_rule_fun(Prefix, Name, Body, Vars, Code) ->
    function(
      dec_atom(Prefix, Name),
      [clause([],[],
              [fun_expr([clause([variable('T')],
                                [],
                                [match_expr(variable('__P'),Body),
                                 case_expr(
                                   application(variable('__P'),[variable('T')]),
                                   [clause([tuple([atom(ok),Vars,variable('_T1')])],
                                           [],
                                           [case is_safe(Code, Vars) of
                                                true ->
                                                    tuple([atom(ok), hd(Code), variable('_T1')]);
                                                false ->
                                                    try_expr(Code,
                                                             [clause([variable('__Ret')],[],
                                                                     [tuple([atom(ok), variable('__Ret'),
                                                                             variable('_T1')])])],
                                                             %% Handlers
                                                             [clause([class_qualifier(atom(throw),
                                                                                      atom(fail))],
                                                                     [],
                                                                     [atom(fail)])
                                                             ]
                                                            )
                                            end]
                                          ),
                                    clause([atom(fail)],[],[atom(fail)])])])])])]).

is_safe(L, Vars) when is_list(L) ->
    lists:all(fun (T) ->
                      is_safe(T, Vars)
              end, L);
is_safe({atom,_,_Val}, _Vars) ->
    true;
is_safe({char,_,_Val}, _Vars) ->
    true;
is_safe({cons,_,Hd,Tl}, Vars) ->
    is_safe(Hd, Vars) and is_safe(Tl, Vars);
is_safe({float,_,_Val}, _Vars) ->
    true;
is_safe({integer,_,_Val}, _Vars) ->
    true;
is_safe({nil,_}, _Vars) ->
    true;
is_safe({tuple,_,Es}, Vars) ->
    is_safe(Es, Vars);
is_safe({var,_,_Var}, _Vars) ->
    true; %lists:member(Var,Vars);
is_safe(_, _Vars) ->
    false.


gen_elem(#seq{elements=Elements}, Type, Prefix) ->
    Body = [gen_elem(Element, Type, Prefix)||Element <- Elements],
    application(atom('__seq'),[list(Body)]);

gen_elem(#alt{alts=Elements}, Type, Prefix) ->
    Alts = [gen_elem(Element, Type, Prefix)||Element <- Elements],
    application(atom('__alt'),[list(Alts)]);

gen_elem(#repeat{min=Min, max=infinity, body=Elem}, Type, Prefix) ->
    application(atom('__repeat'),
                [integer(Min), atom(infinity), gen_elem(Elem, Type, Prefix)]);
gen_elem(#repeat{min=Min, max=Max, body=Elem}, Type, Prefix) ->
    application(atom('__repeat'),
                [integer(Min), integer(Max), gen_elem(Elem, Type, Prefix)]);

gen_elem(#char_val{value=Num}, Type, _Prefix) ->
    PList=mk_plist(Num,Type),
    fun_expr(
      [clause(PList,
              [],
              [tuple([atom(ok), integer(Num), variable('Tl')])]),
       clause([variable('_')], [], [atom(fail)])]);


gen_elem(#char_range{from=From, to=To}, Type, _Prefix) ->
    PList=mk_plist('C',Type),
    fun_expr(
      [clause(
         PList,
         [range_test(variable('C'), From, To)],
         [tuple([atom(ok), variable('C'), variable('Tl')])]),
       clause([variable('_')], [], [atom(fail)])]);

gen_elem(#char_alt{alts=Alts}, Type, _Prefix) ->
    PList=mk_plist('C',Type),
    fun_expr([clause(PList,[char_guard(variable('C'),A)],
                     [tuple([atom(ok),variable('C'),variable('Tl')])])||A<-Alts]
             ++[clause([variable('_')],[],[atom(fail)])]);

gen_elem(#char_seq{elements=Nums}, Type, _Prefix) ->
    ParList = num_par_list(length(Nums), Type),
    Guard = num_guard(Nums),
    Result=[variable(list_to_atom(lists:concat(["C",N]))) || N <- lists:seq(1,length(Nums))],
    fun_expr([clause([ParList],Guard,
                     [tuple([atom(ok), list(Result), variable('Tl')])]),
              clause([variable('_')],[],[atom(fail)])]);

gen_elem(#rulename{name=Rule}, _Type, Prefix) when is_atom(Rule) ->
    application(dec_atom(Prefix, Rule),[]).

mk_plist(Char, binary) when is_integer(Char) ->
    [binary([binary_field(integer(Char)),binary_field(variable('Tl'),[atom('binary')])])];
mk_plist(Var, binary) when is_atom(Var) ->
    [binary([binary_field(variable(Var)),binary_field(variable('Tl'),[atom('binary')])])];
mk_plist(Char, list) when is_integer(Char) ->
    [list([integer(Char)],variable('Tl'))];
mk_plist(Var, list) ->
    [list([variable(Var)],variable('Tl'))].

gen_vars(#seq{elements=Es}) ->
    Vs = list([variable(list_to_atom(lists:concat(["_YY",N])))
               ||N<-lists:seq(1,length(Es))]),
    match_expr(Vs,variable('_YY'));
gen_vars(_) ->
    variable('_YY').

num_guard(Cs) ->
    {_,R} = lists:foldl(
              fun (#char_range{from=From,to=To},{Pos,Acc}) ->
                      Var=variable(list_to_atom(lists:concat(["C",Pos]))),
                      {Pos+1, [range_test(Var, From, To)|Acc]};
                  (#char_val{value=C}, {Pos,Acc}) ->
                      Var=variable(list_to_atom(lists:concat(["C",Pos]))),
                      {Pos+1, [val_test(Var, C)|Acc]};
                  (#char_alt{alts=Alts}, {Pos,Acc}) ->
                      {Pos+1,[num_alt_guard(Pos,Alts)|Acc]}
              end, {1,[]}, Cs),
    conjunction(lists:reverse(R)).

num_par_list(Len, binary) ->
    binary([binary_field(variable(list_to_atom("C"++integer_to_list(N))))||
               N <- lists:seq(1,Len)]++
               [binary_field(variable('Tl'),[atom('binary')])]);
num_par_list(Len, list) ->
    list([variable(list_to_atom("C"++integer_to_list(N))) ||
             N <- lists:seq(1,Len)],variable('Tl')).


num_alt_guard(Var, Alts) ->
    R = lists:foldl(
          fun (#char_range{from=From,to=To},Acc) ->
                  VarT=variable(list_to_atom(lists:concat(["C",Var]))),
                  [range_test(VarT, From, To) |Acc];
              (#char_val{value=C}, Acc) ->
                  VarT=variable(list_to_atom(lists:concat(["C",Var]))),
                  [val_test(VarT, C)|Acc]
          end, [], Alts),
    disjunction(lists:reverse(R)).


char_guard(Var,#char_val{value=Val}) ->
    val_test(Var, Val);
char_guard(Var, #char_range{from=From,to=To}) ->
    range_test(Var, From, To).

range_test(Var, From, To) ->
    infix_expr(infix_expr(Var,operator('>='),integer(From)),
               operator('and'),
               infix_expr(Var,operator('=<'),integer(To))).
val_test(Var, Val) ->
    infix_expr(Var, operator('=='), integer(Val)).

disjunction([H|T]) when T/=[] ->
    infix_expr(H,operator('or'),disjunction(T));
disjunction([As]) ->
    As.


%%====================================================================
%% Internal functions - decode
%%====================================================================

exports_gen(Prefix, Funs) ->
    attribute(atom(export),
              [list([arity_qualifier(atom(generator),integer(1))]++
                        [arity_qualifier(gen_atom(Prefix, F),integer(0))||F<-Funs])]).

include_gen(_Module) ->
    attribute(atom(include_lib),[string("qc/include/qc.hrl")]).

gen_gen(Prefix, Names) ->
    function(atom(generator),
             [clause([atom(Name)],[],
                     [application(gen_atom(Prefix, Name),[])])||Name<-Names]).

gen_generator(#rule{name=Name, body=Element, code=_Code}, Type, Prefix, Verbose) ->
    maybe_write("abnfc_gen: generating generator ~p~p~n\t~p~n~n",[Prefix,Name,Element],Verbose),
    Body = gen_generator_elem(Element, Type, Prefix),
    mk_generator_fun(Prefix, Name, Body).

mk_generator_fun(Prefix, Name, {tree, fun_expr, _, _}=Body) ->
    function(gen_atom(Prefix, Name), [clause([],[], [Body])]);

mk_generator_fun(Prefix, Name, Body) ->
    function(gen_atom(Prefix, Name), [clause([],[], [Body])]).

gen_generator_elem(Element, Type, Prefix) ->
    %% need unique counter :(
    gen_variable_start(),
    Gen = gen_generator_elem1(Element, Type, Prefix),
    gen_variable_stop(),
    Gen.

gen_generator_elem1(Element, list, Prefix) ->
    X = gen_generator_elem2(Element, list, Prefix),
    gen_let(X);
gen_generator_elem1(Element, binary, Prefix) ->
    X = gen_generator_elem2(Element, list, Prefix),
    gen_let_binary(X).

gen_generator_elem2(#seq{elements=Elements}, list, Prefix) ->
    Elts = [gen_generator_elem2(Element, list, Prefix)||Element <- Elements],
    X = application(atom('__seq_generator'), [list(Elts)]),
    gen_let(X);

gen_generator_elem2(#alt{alts=Elements}, list, Prefix) ->
    Alts = [gen_generator_elem2(Element, list, Prefix)||Element <- Elements],
    X = application(atom(oneof), [list(Alts)]),
    gen_let(X);

gen_generator_elem2(#repeat{min=Min, max=infinity, body=Elem}, list, Prefix) ->
    X = application(atom('__repeat_generator'),
                    [integer(Min), atom(infinity), gen_generator_elem2(Elem, list, Prefix)]),
    gen_let(X);

gen_generator_elem2(#repeat{min=Min, max=Max, body=Elem}, list, Prefix) ->
    X = application(atom('__repeat_generator'),
                    [integer(Min), integer(Max), gen_generator_elem2(Elem, list, Prefix)]),
    gen_let(X);

gen_generator_elem2(#char_val{value=Num}, list, _Prefix) ->
    X = integer(Num),
    gen_let(X);

gen_generator_elem2(#char_range{from=From, to=To}, list, _Prefix) ->
    X = application(atom(choose), [integer(From), integer(To)]),
    gen_let(X);

gen_generator_elem2(#char_alt{alts=Elements}, list, Prefix) ->
    Alts = [gen_generator_elem2(Element, list, Prefix)||Element <- Elements],
    X = application(atom(oneof), [list(Alts)]),
    gen_let(X);

gen_generator_elem2(#char_seq{elements=Elements}, list, Prefix) ->
    Elts = [gen_generator_elem2(Element, list, Prefix)||Element <- Elements],
    X = application(atom('__seq_generator'), [list(Elts)]),
    gen_let(X);

gen_generator_elem2(#rulename{name=Generator}, _Type, Prefix) when is_atom(Generator) ->
    V = gen_variable(),
    %% option #1
    %% macro(atom('SIZED'),
    %%       [V, application(atom(resize),
    %%                       [if_expr([clause([],
    %%                                        infix_expr(V,operator('>'),integer(0)),
    %%                                        [infix_expr(V,operator('-'),integer(1))]),
    %%                                 clause([],
    %%                                        atom(true),
    %%                                        [integer(0)])]),
    %%                        application(gen_atom(Prefix, Generator), [])])]).
    %% option #2
    macro(atom('SIZED'),
          [V, application(atom(resize),
                          [application(atom(erlang), atom(round), [application(atom(math), atom(sqrt), [V])]),
                           application(gen_atom(Prefix, Generator), [])])]).

gen_let(X) ->
    V = gen_variable(),
    macro(atom('LET'), [V, X, V]).

gen_let_binary(X) ->
    V = gen_variable(),
    macro(atom('LET'), [V, X, application(atom(erlang), atom(list_to_binary), [list([V])])]).

gen_atom(Prefix, A) ->
    atom(list_to_atom(atom_to_list(Prefix)++atom_to_list(A)++"_generator")).

gen_ifdef(F) ->
    form_list([attribute(atom(ifdef),[atom('QC')]),
               F,
               attribute(atom(endif))]).

gen_variable_start() ->
    put(?MODULE, 1).

gen_variable_stop() ->
    erase(?MODULE).

gen_variable() ->
    N = get(?MODULE),
    put(?MODULE, N+1),
    variable(list_to_atom("V" ++ integer_to_list(N))).

%%================================================
%% Run-time support functions - decode
%%================================================
%% Match one of several parsers.

mk__alt() ->
    function(atom('__alt'),
             [clause(
                [variable('Ps')],
                [],
                [fun_expr(
                   [clause(
                      [variable('T')],
                      [],
                      [application(atom('__do_alt'), [variable('Ps'),variable('T')])]
                     )]
                  )]
               )]
            ).

mk__do_alt() ->
    function(atom('__do_alt'),
             [clause(
                [list([variable('P')],variable('Ps')),variable('T')],
                [],
                [
                 case_expr(
                   application(variable('P'),[variable('T')]),
                   [clause([match_expr(tuple([atom(ok),variable('_R'),variable('_T1')]),
                                       variable('Res'))],[],
                           [variable('Res')]),
                    clause([atom(fail)],[],
                           [application(atom('__do_alt'), [variable('Ps'),variable('T')])
                           ]
                          )]
                  )]
               ),
              clause([nil(),variable('_')],[],[atom(fail)])
             ]
            ).


%% Match between Min and Max repetitions of parser P
mk__repeat() ->
    form_list([mk__repeat_3(),
               mk__repeat_4(),
               mk__do_repeat()]).

mk__repeat_3() ->
    function(atom('__repeat'),
             [clause(
                [variable('Min'),variable('Max'),variable('P')],
                [],
                [application(atom('__repeat'),
                             [variable('Min'),
                              variable('Max'),
                              variable('P'),
                              integer(0)])])]).

mk__repeat_4() ->
    function(atom('__repeat'),
             [clause(
                [variable('Min'),variable('Max'),variable('P'), variable('Found')],
                [],
                [fun_expr(
                   [clause(
                      [variable('T')],
                      [],
                      [application(atom('__do_repeat'), [variable('Min'),
                                                         variable('Max'),
                                                         variable('P'),
                                                         variable('Found'),
                                                         variable('T')])]
                     )]
                  )]
               )]
            ).


mk__do_repeat() ->
    function(atom('__do_repeat'),
             [clause(
                [variable('Min'),variable('Max'),variable('P'), variable('Found'),variable('T')],
                [],
                [case_expr(
                   application(variable('P'),[variable('T')]),
                   [
                    clause([tuple([atom(ok),variable('R1'),variable('T1')])],
                           [infix_expr(variable('Max'),operator('=='),
                                       infix_expr(variable('Found'),operator('+'),
                                                  integer(1)))],
                           [tuple([atom(ok),list([variable('R1')]),variable('T1')])]),
                    clause([tuple([atom(ok),variable('R1'),variable('T1')])],
                           [],
                           [
                            case_expr(application(atom('__do_repeat'),
                                                  [variable('Min'),
                                                   variable('Max'),
                                                   variable('P'),
                                                   infix_expr(variable('Found'),
                                                              operator('+'),
                                                              integer(1)),
                                                   variable('T1')]),
                                      [clause([tuple([atom(ok),variable('R2'),
                                                      variable('T2')])],
                                              [],
                                              [tuple([atom(ok),
                                                      list([variable('R1')],variable('R2')),
                                                      variable('T2')])]),
                                       clause([atom(fail)],
                                              [infix_expr(variable('Found'),
                                                          operator('>='),
                                                          variable('Min'))],
                                              [tuple([atom(ok),list([variable('R1')]),
                                                      variable('T1')])]),
                                       clause([atom(fail)],
                                              [],[atom(fail)])
                                      ])]),
                    clause([atom(fail)],
                           [infix_expr(variable('Found'),operator('>='),variable('Min'))],
                           [tuple([atom(ok),nil(),variable('T')])]),
                    clause([atom(fail)],
                           [],[atom(fail)])
                   ])
                ])]).

%% Match a sequence of parsers.
mk__seq() ->
    function(atom('__seq'),
             [clause(
                [variable('Ps')],
                [],
                [fun_expr(
                   [clause(
                      [variable('T')],
                      [],
                      [application(atom('__do_seq'), [variable('Ps'),variable('T')])]
                     )]
                  )]
               )]
            ).



mk__do_seq() ->
    function(atom('__do_seq'),
             [clause(
                [list([variable('P')],variable('Ps')),variable('T')],
                [],
                [
                 case_expr(
                   application(variable('P'),[variable('T')]),
                   [clause([tuple([atom(ok),variable('R1'),variable('T1')])],
                           [],
                           [
                            case_expr(
                              application(atom('__do_seq'),[variable('Ps'),variable('T1')]),
                              [clause([tuple([atom(ok),variable('R2'),variable('T2')])],
                                      [],
                                      [tuple([atom(ok),list([variable('R1')],
                                                            variable('R2')),
                                              variable('T2')])]),
                               clause([atom(fail)],[],[atom(fail)])])]),
                    clause([atom(fail)],[],[atom(fail)])])]),
              clause([nil(),variable('T')],[],
                     [tuple([atom(ok),list([]),variable('T')])])]).


%%================================================
%% Run-time support functions - generator
%%================================================

mk__repeat_generator() ->
    function(atom('__repeat_generator'),
             [clause(
                [variable('Min'),variable('Max'),variable('G')],
                [],
                [macro(atom('SIZED'),
                       [variable('Size'),
                        block_expr([infix_expr(variable('MAX'),operator('='),
                                               if_expr([clause([],
                                                               infix_expr(variable('Max'),operator('/='),atom(infinity)),
                                                               [variable('Max')]),
                                                        clause([],
                                                               atom(true),
                                                               [variable('Size')])])),
                                    macro(atom('LET'),
                                          [variable('K'),
                                           if_expr([clause([],
                                                           infix_expr(variable('Min'),operator('>='),variable('MAX')),
                                                           [variable('Min')]),
                                                    clause([],
                                                           atom(true),
                                                           [application(atom(choose),[variable('Min'),variable('MAX')])])]),
                                           application(atom(vector),[variable('K'), variable('G')])])
                                   ])
                       ])
                ])]).

mk__seq_generator() ->
    function(atom('__seq_generator'),
             [clause(
                [variable('Gs')],
                [],
                [application(atom('__do_seq_generator'),[variable('Gs'),list([])])])]).

mk__do_seq_generator() ->
    function(atom('__do_seq_generator'),
             [clause(
                [list([]),variable('Acc')],
                [],
                [application(atom(lists),atom(reverse),[variable('Acc')])]),
              clause(
                [cons(variable('H'),variable('T')),variable('Acc')],
                [],
                [macro(atom('LET'),
                       [variable('K'),
                        variable('H'),
                        application(atom('__do_seq_generator'),[variable('T'),cons(variable('K'),variable('Acc'))])])])]).
